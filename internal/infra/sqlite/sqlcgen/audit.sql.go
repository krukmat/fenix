// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit.sql

package sqlcgen

import (
	"context"
	"encoding/json"
	"time"
)

const countAuditEventsByWorkspace = `-- name: CountAuditEventsByWorkspace :one
SELECT COUNT(*) FROM audit_event WHERE workspace_id = ?
`

// Counts total audit events for a workspace
func (q *Queries) CountAuditEventsByWorkspace(ctx context.Context, workspaceID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAuditEventsByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditEvent = `-- name: CreateAuditEvent :exec

INSERT INTO audit_event (
    id, workspace_id, actor_id, actor_type, action,
    entity_type, entity_id, details, permissions_checked,
    outcome, trace_id, ip_address, user_agent, created_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateAuditEventParams struct {
	ID                 string          `db:"id" json:"id"`
	WorkspaceID        string          `db:"workspace_id" json:"workspaceId"`
	ActorID            string          `db:"actor_id" json:"actorId"`
	ActorType          string          `db:"actor_type" json:"actorType"`
	Action             string          `db:"action" json:"action"`
	EntityType         *string         `db:"entity_type" json:"entityType"`
	EntityID           *string         `db:"entity_id" json:"entityId"`
	Details            json.RawMessage `db:"details" json:"details"`
	PermissionsChecked json.RawMessage `db:"permissions_checked" json:"permissionsChecked"`
	Outcome            string          `db:"outcome" json:"outcome"`
	TraceID            *string         `db:"trace_id" json:"traceId"`
	IpAddress          *string         `db:"ip_address" json:"ipAddress"`
	UserAgent          *string         `db:"user_agent" json:"userAgent"`
	CreatedAt          time.Time       `db:"created_at" json:"createdAt"`
}

// Queries for audit_event table
// Related to: Task 1.7, internal/domain/audit
// Creates a new audit event (append-only, immutable)
func (q *Queries) CreateAuditEvent(ctx context.Context, arg CreateAuditEventParams) error {
	_, err := q.db.ExecContext(ctx, createAuditEvent,
		arg.ID,
		arg.WorkspaceID,
		arg.ActorID,
		arg.ActorType,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.Details,
		arg.PermissionsChecked,
		arg.Outcome,
		arg.TraceID,
		arg.IpAddress,
		arg.UserAgent,
		arg.CreatedAt,
	)
	return err
}

const getAuditEventByID = `-- name: GetAuditEventByID :one
SELECT id, workspace_id, actor_id, actor_type, "action", entity_type, entity_id, details, permissions_checked, outcome, trace_id, ip_address, user_agent, created_at FROM audit_event WHERE id = ? LIMIT 1
`

// Retrieves a single audit event by ID
func (q *Queries) GetAuditEventByID(ctx context.Context, id string) (AuditEvent, error) {
	row := q.db.QueryRowContext(ctx, getAuditEventByID, id)
	var i AuditEvent
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ActorID,
		&i.ActorType,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.Details,
		&i.PermissionsChecked,
		&i.Outcome,
		&i.TraceID,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const listAuditEventsByAction = `-- name: ListAuditEventsByAction :many
SELECT id, workspace_id, actor_id, actor_type, "action", entity_type, entity_id, details, permissions_checked, outcome, trace_id, ip_address, user_agent, created_at FROM audit_event
WHERE workspace_id = ? AND action = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAuditEventsByActionParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Action      string `db:"action" json:"action"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

// Lists audit events filtered by action type
func (q *Queries) ListAuditEventsByAction(ctx context.Context, arg ListAuditEventsByActionParams) ([]AuditEvent, error) {
	rows, err := q.db.QueryContext(ctx, listAuditEventsByAction,
		arg.WorkspaceID,
		arg.Action,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditEvent{}
	for rows.Next() {
		var i AuditEvent
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActorID,
			&i.ActorType,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.Details,
			&i.PermissionsChecked,
			&i.Outcome,
			&i.TraceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditEventsByActor = `-- name: ListAuditEventsByActor :many
SELECT id, workspace_id, actor_id, actor_type, "action", entity_type, entity_id, details, permissions_checked, outcome, trace_id, ip_address, user_agent, created_at FROM audit_event
WHERE actor_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListAuditEventsByActorParams struct {
	ActorID string `db:"actor_id" json:"actorId"`
	Limit   int64  `db:"limit" json:"limit"`
}

// Lists audit events for a specific actor
func (q *Queries) ListAuditEventsByActor(ctx context.Context, arg ListAuditEventsByActorParams) ([]AuditEvent, error) {
	rows, err := q.db.QueryContext(ctx, listAuditEventsByActor, arg.ActorID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditEvent{}
	for rows.Next() {
		var i AuditEvent
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActorID,
			&i.ActorType,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.Details,
			&i.PermissionsChecked,
			&i.Outcome,
			&i.TraceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditEventsByEntity = `-- name: ListAuditEventsByEntity :many
SELECT id, workspace_id, actor_id, actor_type, "action", entity_type, entity_id, details, permissions_checked, outcome, trace_id, ip_address, user_agent, created_at FROM audit_event
WHERE entity_type = ? AND entity_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListAuditEventsByEntityParams struct {
	EntityType *string `db:"entity_type" json:"entityType"`
	EntityID   *string `db:"entity_id" json:"entityId"`
	Limit      int64   `db:"limit" json:"limit"`
}

// Lists audit events for a specific entity
func (q *Queries) ListAuditEventsByEntity(ctx context.Context, arg ListAuditEventsByEntityParams) ([]AuditEvent, error) {
	rows, err := q.db.QueryContext(ctx, listAuditEventsByEntity, arg.EntityType, arg.EntityID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditEvent{}
	for rows.Next() {
		var i AuditEvent
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActorID,
			&i.ActorType,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.Details,
			&i.PermissionsChecked,
			&i.Outcome,
			&i.TraceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditEventsByOutcome = `-- name: ListAuditEventsByOutcome :many
SELECT id, workspace_id, actor_id, actor_type, "action", entity_type, entity_id, details, permissions_checked, outcome, trace_id, ip_address, user_agent, created_at FROM audit_event
WHERE workspace_id = ? AND outcome = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAuditEventsByOutcomeParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Outcome     string `db:"outcome" json:"outcome"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

// Lists audit events filtered by outcome (success/denied/error)
func (q *Queries) ListAuditEventsByOutcome(ctx context.Context, arg ListAuditEventsByOutcomeParams) ([]AuditEvent, error) {
	rows, err := q.db.QueryContext(ctx, listAuditEventsByOutcome,
		arg.WorkspaceID,
		arg.Outcome,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditEvent{}
	for rows.Next() {
		var i AuditEvent
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActorID,
			&i.ActorType,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.Details,
			&i.PermissionsChecked,
			&i.Outcome,
			&i.TraceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditEventsByTimeRange = `-- name: ListAuditEventsByTimeRange :many
SELECT id, workspace_id, actor_id, actor_type, "action", entity_type, entity_id, details, permissions_checked, outcome, trace_id, ip_address, user_agent, created_at FROM audit_event
WHERE workspace_id = ? AND created_at BETWEEN ? AND ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAuditEventsByTimeRangeParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

// Lists audit events within a time range
func (q *Queries) ListAuditEventsByTimeRange(ctx context.Context, arg ListAuditEventsByTimeRangeParams) ([]AuditEvent, error) {
	rows, err := q.db.QueryContext(ctx, listAuditEventsByTimeRange, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditEvent{}
	for rows.Next() {
		var i AuditEvent
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActorID,
			&i.ActorType,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.Details,
			&i.PermissionsChecked,
			&i.Outcome,
			&i.TraceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditEventsByWorkspace = `-- name: ListAuditEventsByWorkspace :many
SELECT id, workspace_id, actor_id, actor_type, "action", entity_type, entity_id, details, permissions_checked, outcome, trace_id, ip_address, user_agent, created_at FROM audit_event
WHERE workspace_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListAuditEventsByWorkspaceParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

// Lists audit events for a workspace with pagination
// Results ordered by created_at DESC (newest first)
func (q *Queries) ListAuditEventsByWorkspace(ctx context.Context, arg ListAuditEventsByWorkspaceParams) ([]AuditEvent, error) {
	rows, err := q.db.QueryContext(ctx, listAuditEventsByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditEvent{}
	for rows.Next() {
		var i AuditEvent
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActorID,
			&i.ActorType,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.Details,
			&i.PermissionsChecked,
			&i.Outcome,
			&i.TraceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
