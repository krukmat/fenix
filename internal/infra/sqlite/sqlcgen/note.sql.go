// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: note.sql

package sqlcgen

import (
	"context"
)

const countNotesByEntity = `-- name: CountNotesByEntity :one
SELECT COUNT(*) FROM note
WHERE workspace_id = ?
  AND entity_type = ?
  AND entity_id = ?
`

type CountNotesByEntityParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	EntityType  string `db:"entity_type" json:"entityType"`
	EntityID    string `db:"entity_id" json:"entityId"`
}

func (q *Queries) CountNotesByEntity(ctx context.Context, arg CountNotesByEntityParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotesByEntity, arg.WorkspaceID, arg.EntityType, arg.EntityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNotesByWorkspace = `-- name: CountNotesByWorkspace :one
SELECT COUNT(*) FROM note
WHERE workspace_id = ?
`

func (q *Queries) CountNotesByWorkspace(ctx context.Context, workspaceID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotesByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNote = `-- name: CreateNote :exec

INSERT INTO note (id, workspace_id, entity_type, entity_id, author_id, content, is_internal, metadata, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateNoteParams struct {
	ID          string  `db:"id" json:"id"`
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
	EntityType  string  `db:"entity_type" json:"entityType"`
	EntityID    string  `db:"entity_id" json:"entityId"`
	AuthorID    string  `db:"author_id" json:"authorId"`
	Content     string  `db:"content" json:"content"`
	IsInternal  bool    `db:"is_internal" json:"isInternal"`
	Metadata    *string `db:"metadata" json:"metadata"`
	CreatedAt   string  `db:"created_at" json:"createdAt"`
	UpdatedAt   string  `db:"updated_at" json:"updatedAt"`
}

// SQL queries for note table
// Task 1.5: Note/comment management queries
func (q *Queries) CreateNote(ctx context.Context, arg CreateNoteParams) error {
	_, err := q.db.ExecContext(ctx, createNote,
		arg.ID,
		arg.WorkspaceID,
		arg.EntityType,
		arg.EntityID,
		arg.AuthorID,
		arg.Content,
		arg.IsInternal,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteNote = `-- name: DeleteNote :exec
DELETE FROM note
WHERE id = ?
  AND workspace_id = ?
`

type DeleteNoteParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) DeleteNote(ctx context.Context, arg DeleteNoteParams) error {
	_, err := q.db.ExecContext(ctx, deleteNote, arg.ID, arg.WorkspaceID)
	return err
}

const getNoteByID = `-- name: GetNoteByID :one
SELECT id, workspace_id, entity_type, entity_id, author_id, content, is_internal, metadata, created_at, updated_at
FROM note
WHERE id = ?
  AND workspace_id = ?
LIMIT 1
`

type GetNoteByIDParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) GetNoteByID(ctx context.Context, arg GetNoteByIDParams) (Note, error) {
	row := q.db.QueryRowContext(ctx, getNoteByID, arg.ID, arg.WorkspaceID)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.EntityType,
		&i.EntityID,
		&i.AuthorID,
		&i.Content,
		&i.IsInternal,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listNotesByAuthor = `-- name: ListNotesByAuthor :many
SELECT id, workspace_id, entity_type, entity_id, author_id, content, is_internal, metadata, created_at, updated_at
FROM note
WHERE workspace_id = ?
  AND author_id = ?
ORDER BY created_at DESC
`

type ListNotesByAuthorParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	AuthorID    string `db:"author_id" json:"authorId"`
}

func (q *Queries) ListNotesByAuthor(ctx context.Context, arg ListNotesByAuthorParams) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesByAuthor, arg.WorkspaceID, arg.AuthorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Note{}
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.EntityType,
			&i.EntityID,
			&i.AuthorID,
			&i.Content,
			&i.IsInternal,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByEntity = `-- name: ListNotesByEntity :many
SELECT id, workspace_id, entity_type, entity_id, author_id, content, is_internal, metadata, created_at, updated_at
FROM note
WHERE workspace_id = ?
  AND entity_type = ?
  AND entity_id = ?
ORDER BY created_at DESC
`

type ListNotesByEntityParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	EntityType  string `db:"entity_type" json:"entityType"`
	EntityID    string `db:"entity_id" json:"entityId"`
}

func (q *Queries) ListNotesByEntity(ctx context.Context, arg ListNotesByEntityParams) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesByEntity, arg.WorkspaceID, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Note{}
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.EntityType,
			&i.EntityID,
			&i.AuthorID,
			&i.Content,
			&i.IsInternal,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByEntityPublic = `-- name: ListNotesByEntityPublic :many
SELECT id, workspace_id, entity_type, entity_id, author_id, content, is_internal, metadata, created_at, updated_at
FROM note
WHERE workspace_id = ?
  AND entity_type = ?
  AND entity_id = ?
  AND is_internal = 0
ORDER BY created_at DESC
`

type ListNotesByEntityPublicParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	EntityType  string `db:"entity_type" json:"entityType"`
	EntityID    string `db:"entity_id" json:"entityId"`
}

func (q *Queries) ListNotesByEntityPublic(ctx context.Context, arg ListNotesByEntityPublicParams) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesByEntityPublic, arg.WorkspaceID, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Note{}
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.EntityType,
			&i.EntityID,
			&i.AuthorID,
			&i.Content,
			&i.IsInternal,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByWorkspace = `-- name: ListNotesByWorkspace :many
SELECT id, workspace_id, entity_type, entity_id, author_id, content, is_internal, metadata, created_at, updated_at
FROM note
WHERE workspace_id = ?
ORDER BY created_at DESC
LIMIT ?
OFFSET ?
`

type ListNotesByWorkspaceParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

func (q *Queries) ListNotesByWorkspace(ctx context.Context, arg ListNotesByWorkspaceParams) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Note{}
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.EntityType,
			&i.EntityID,
			&i.AuthorID,
			&i.Content,
			&i.IsInternal,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNote = `-- name: UpdateNote :exec
UPDATE note
SET content = ?,
    is_internal = ?,
    metadata = ?,
    updated_at = ?
WHERE id = ?
  AND workspace_id = ?
`

type UpdateNoteParams struct {
	Content     string  `db:"content" json:"content"`
	IsInternal  bool    `db:"is_internal" json:"isInternal"`
	Metadata    *string `db:"metadata" json:"metadata"`
	UpdatedAt   string  `db:"updated_at" json:"updatedAt"`
	ID          string  `db:"id" json:"id"`
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) UpdateNote(ctx context.Context, arg UpdateNoteParams) error {
	_, err := q.db.ExecContext(ctx, updateNote,
		arg.Content,
		arg.IsInternal,
		arg.Metadata,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}
