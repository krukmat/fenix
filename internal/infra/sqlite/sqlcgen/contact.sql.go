// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: contact.sql

package sqlcgen

import (
	"context"
)

const countContactsByWorkspace = `-- name: CountContactsByWorkspace :one
SELECT COUNT(*)
FROM contact
WHERE workspace_id = ?
  AND deleted_at IS NULL
`

func (q *Queries) CountContactsByWorkspace(ctx context.Context, workspaceID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContactsByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createContact = `-- name: CreateContact :exec

INSERT INTO contact (
    id,
    workspace_id,
    account_id,
    first_name,
    last_name,
    email,
    phone,
    title,
    status,
    owner_id,
    metadata,
    created_at,
    updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateContactParams struct {
	ID          string  `db:"id" json:"id"`
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
	AccountID   string  `db:"account_id" json:"accountId"`
	FirstName   string  `db:"first_name" json:"firstName"`
	LastName    string  `db:"last_name" json:"lastName"`
	Email       *string `db:"email" json:"email"`
	Phone       *string `db:"phone" json:"phone"`
	Title       *string `db:"title" json:"title"`
	Status      string  `db:"status" json:"status"`
	OwnerID     string  `db:"owner_id" json:"ownerId"`
	Metadata    *string `db:"metadata" json:"metadata"`
	CreatedAt   string  `db:"created_at" json:"createdAt"`
	UpdatedAt   string  `db:"updated_at" json:"updatedAt"`
}

// SQL queries for contact table
// Task 1.4: sqlc-annotated queries
// IMPORTANT: All contact queries filter by workspace_id for multi-tenancy isolation.
func (q *Queries) CreateContact(ctx context.Context, arg CreateContactParams) error {
	_, err := q.db.ExecContext(ctx, createContact,
		arg.ID,
		arg.WorkspaceID,
		arg.AccountID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.Title,
		arg.Status,
		arg.OwnerID,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const getContactByID = `-- name: GetContactByID :one
SELECT id, workspace_id, account_id, first_name, last_name, email, phone, title, status, owner_id, metadata, created_at, updated_at, deleted_at
FROM contact
WHERE id = ?
  AND workspace_id = ?
  AND deleted_at IS NULL
LIMIT 1
`

type GetContactByIDParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) GetContactByID(ctx context.Context, arg GetContactByIDParams) (Contact, error) {
	row := q.db.QueryRowContext(ctx, getContactByID, arg.ID, arg.WorkspaceID)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.AccountID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.Title,
		&i.Status,
		&i.OwnerID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listContactsByAccount = `-- name: ListContactsByAccount :many
SELECT id, workspace_id, account_id, first_name, last_name, email, phone, title, status, owner_id, metadata, created_at, updated_at, deleted_at
FROM contact
WHERE workspace_id = ?
  AND account_id = ?
  AND deleted_at IS NULL
ORDER BY first_name ASC, last_name ASC
`

type ListContactsByAccountParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	AccountID   string `db:"account_id" json:"accountId"`
}

func (q *Queries) ListContactsByAccount(ctx context.Context, arg ListContactsByAccountParams) ([]Contact, error) {
	rows, err := q.db.QueryContext(ctx, listContactsByAccount, arg.WorkspaceID, arg.AccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.Title,
			&i.Status,
			&i.OwnerID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContactsByWorkspace = `-- name: ListContactsByWorkspace :many
SELECT id, workspace_id, account_id, first_name, last_name, email, phone, title, status, owner_id, metadata, created_at, updated_at, deleted_at
FROM contact
WHERE workspace_id = ?
  AND deleted_at IS NULL
ORDER BY first_name ASC, last_name ASC
LIMIT ?
OFFSET ?
`

type ListContactsByWorkspaceParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

func (q *Queries) ListContactsByWorkspace(ctx context.Context, arg ListContactsByWorkspaceParams) ([]Contact, error) {
	rows, err := q.db.QueryContext(ctx, listContactsByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.Title,
			&i.Status,
			&i.OwnerID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteContact = `-- name: SoftDeleteContact :exec
UPDATE contact
SET deleted_at = ?,
    updated_at = ?
WHERE id = ?
  AND workspace_id = ?
  AND deleted_at IS NULL
`

type SoftDeleteContactParams struct {
	DeletedAt   *string `db:"deleted_at" json:"deletedAt"`
	UpdatedAt   string  `db:"updated_at" json:"updatedAt"`
	ID          string  `db:"id" json:"id"`
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) SoftDeleteContact(ctx context.Context, arg SoftDeleteContactParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteContact,
		arg.DeletedAt,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}

const updateContact = `-- name: UpdateContact :exec
UPDATE contact
SET account_id = ?,
    first_name = ?,
    last_name = ?,
    email = ?,
    phone = ?,
    title = ?,
    status = ?,
    owner_id = ?,
    metadata = ?,
    updated_at = ?
WHERE id = ?
  AND workspace_id = ?
  AND deleted_at IS NULL
`

type UpdateContactParams struct {
	AccountID   string  `db:"account_id" json:"accountId"`
	FirstName   string  `db:"first_name" json:"firstName"`
	LastName    string  `db:"last_name" json:"lastName"`
	Email       *string `db:"email" json:"email"`
	Phone       *string `db:"phone" json:"phone"`
	Title       *string `db:"title" json:"title"`
	Status      string  `db:"status" json:"status"`
	OwnerID     string  `db:"owner_id" json:"ownerId"`
	Metadata    *string `db:"metadata" json:"metadata"`
	UpdatedAt   string  `db:"updated_at" json:"updatedAt"`
	ID          string  `db:"id" json:"id"`
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) UpdateContact(ctx context.Context, arg UpdateContactParams) error {
	_, err := q.db.ExecContext(ctx, updateContact,
		arg.AccountID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.Title,
		arg.Status,
		arg.OwnerID,
		arg.Metadata,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}
