// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: deal.sql

package sqlcgen

import (
	"context"
)

const countDealsByPipeline = `-- name: CountDealsByPipeline :one
SELECT COUNT(*) FROM deal
WHERE workspace_id = ?
  AND pipeline_id = ?
  AND deleted_at IS NULL
`

type CountDealsByPipelineParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	PipelineID  string `db:"pipeline_id" json:"pipelineId"`
}

func (q *Queries) CountDealsByPipeline(ctx context.Context, arg CountDealsByPipelineParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDealsByPipeline, arg.WorkspaceID, arg.PipelineID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDealsByWorkspace = `-- name: CountDealsByWorkspace :one
SELECT COUNT(*) FROM deal
WHERE workspace_id = ?
  AND deleted_at IS NULL
`

func (q *Queries) CountDealsByWorkspace(ctx context.Context, workspaceID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDealsByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDeal = `-- name: CreateDeal :exec

INSERT INTO deal (id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, title, amount, currency, expected_close, status, metadata, created_at, updated_at, deleted_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateDealParams struct {
	ID            string   `db:"id" json:"id"`
	WorkspaceID   string   `db:"workspace_id" json:"workspaceId"`
	AccountID     string   `db:"account_id" json:"accountId"`
	ContactID     *string  `db:"contact_id" json:"contactId"`
	PipelineID    string   `db:"pipeline_id" json:"pipelineId"`
	StageID       string   `db:"stage_id" json:"stageId"`
	OwnerID       string   `db:"owner_id" json:"ownerId"`
	Title         string   `db:"title" json:"title"`
	Amount        *float64 `db:"amount" json:"amount"`
	Currency      *string  `db:"currency" json:"currency"`
	ExpectedClose *string  `db:"expected_close" json:"expectedClose"`
	Status        string   `db:"status" json:"status"`
	Metadata      *string  `db:"metadata" json:"metadata"`
	CreatedAt     string   `db:"created_at" json:"createdAt"`
	UpdatedAt     string   `db:"updated_at" json:"updatedAt"`
	DeletedAt     *string  `db:"deleted_at" json:"deletedAt"`
}

// SQL queries for deal table
// Task 1.5: Deal management queries
func (q *Queries) CreateDeal(ctx context.Context, arg CreateDealParams) error {
	_, err := q.db.ExecContext(ctx, createDeal,
		arg.ID,
		arg.WorkspaceID,
		arg.AccountID,
		arg.ContactID,
		arg.PipelineID,
		arg.StageID,
		arg.OwnerID,
		arg.Title,
		arg.Amount,
		arg.Currency,
		arg.ExpectedClose,
		arg.Status,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}

const getDealByID = `-- name: GetDealByID :one
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, title, amount, currency, expected_close, status, metadata, created_at, updated_at, deleted_at
FROM deal
WHERE id = ?
  AND workspace_id = ?
  AND deleted_at IS NULL
LIMIT 1
`

type GetDealByIDParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) GetDealByID(ctx context.Context, arg GetDealByIDParams) (Deal, error) {
	row := q.db.QueryRowContext(ctx, getDealByID, arg.ID, arg.WorkspaceID)
	var i Deal
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.AccountID,
		&i.ContactID,
		&i.PipelineID,
		&i.StageID,
		&i.OwnerID,
		&i.Title,
		&i.Amount,
		&i.Currency,
		&i.ExpectedClose,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listDealsByAccount = `-- name: ListDealsByAccount :many
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, title, amount, currency, expected_close, status, metadata, created_at, updated_at, deleted_at
FROM deal
WHERE workspace_id = ?
  AND account_id = ?
  AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListDealsByAccountParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	AccountID   string `db:"account_id" json:"accountId"`
}

func (q *Queries) ListDealsByAccount(ctx context.Context, arg ListDealsByAccountParams) ([]Deal, error) {
	rows, err := q.db.QueryContext(ctx, listDealsByAccount, arg.WorkspaceID, arg.AccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.ContactID,
			&i.PipelineID,
			&i.StageID,
			&i.OwnerID,
			&i.Title,
			&i.Amount,
			&i.Currency,
			&i.ExpectedClose,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDealsByOwner = `-- name: ListDealsByOwner :many
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, title, amount, currency, expected_close, status, metadata, created_at, updated_at, deleted_at
FROM deal
WHERE workspace_id = ?
  AND owner_id = ?
  AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListDealsByOwnerParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	OwnerID     string `db:"owner_id" json:"ownerId"`
}

func (q *Queries) ListDealsByOwner(ctx context.Context, arg ListDealsByOwnerParams) ([]Deal, error) {
	rows, err := q.db.QueryContext(ctx, listDealsByOwner, arg.WorkspaceID, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.ContactID,
			&i.PipelineID,
			&i.StageID,
			&i.OwnerID,
			&i.Title,
			&i.Amount,
			&i.Currency,
			&i.ExpectedClose,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDealsByPipeline = `-- name: ListDealsByPipeline :many
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, title, amount, currency, expected_close, status, metadata, created_at, updated_at, deleted_at
FROM deal
WHERE workspace_id = ?
  AND pipeline_id = ?
  AND deleted_at IS NULL
ORDER BY stage_id, created_at DESC
`

type ListDealsByPipelineParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	PipelineID  string `db:"pipeline_id" json:"pipelineId"`
}

func (q *Queries) ListDealsByPipeline(ctx context.Context, arg ListDealsByPipelineParams) ([]Deal, error) {
	rows, err := q.db.QueryContext(ctx, listDealsByPipeline, arg.WorkspaceID, arg.PipelineID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.ContactID,
			&i.PipelineID,
			&i.StageID,
			&i.OwnerID,
			&i.Title,
			&i.Amount,
			&i.Currency,
			&i.ExpectedClose,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDealsByStage = `-- name: ListDealsByStage :many
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, title, amount, currency, expected_close, status, metadata, created_at, updated_at, deleted_at
FROM deal
WHERE workspace_id = ?
  AND stage_id = ?
  AND deleted_at IS NULL
  AND status = 'open'
ORDER BY created_at DESC
`

type ListDealsByStageParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	StageID     string `db:"stage_id" json:"stageId"`
}

func (q *Queries) ListDealsByStage(ctx context.Context, arg ListDealsByStageParams) ([]Deal, error) {
	rows, err := q.db.QueryContext(ctx, listDealsByStage, arg.WorkspaceID, arg.StageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.ContactID,
			&i.PipelineID,
			&i.StageID,
			&i.OwnerID,
			&i.Title,
			&i.Amount,
			&i.Currency,
			&i.ExpectedClose,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDealsByStatus = `-- name: ListDealsByStatus :many
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, title, amount, currency, expected_close, status, metadata, created_at, updated_at, deleted_at
FROM deal
WHERE workspace_id = ?
  AND status = ?
  AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListDealsByStatusParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Status      string `db:"status" json:"status"`
}

func (q *Queries) ListDealsByStatus(ctx context.Context, arg ListDealsByStatusParams) ([]Deal, error) {
	rows, err := q.db.QueryContext(ctx, listDealsByStatus, arg.WorkspaceID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.ContactID,
			&i.PipelineID,
			&i.StageID,
			&i.OwnerID,
			&i.Title,
			&i.Amount,
			&i.Currency,
			&i.ExpectedClose,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDealsByWorkspace = `-- name: ListDealsByWorkspace :many
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, title, amount, currency, expected_close, status, metadata, created_at, updated_at, deleted_at
FROM deal
WHERE workspace_id = ?
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT ?
OFFSET ?
`

type ListDealsByWorkspaceParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

func (q *Queries) ListDealsByWorkspace(ctx context.Context, arg ListDealsByWorkspaceParams) ([]Deal, error) {
	rows, err := q.db.QueryContext(ctx, listDealsByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.ContactID,
			&i.PipelineID,
			&i.StageID,
			&i.OwnerID,
			&i.Title,
			&i.Amount,
			&i.Currency,
			&i.ExpectedClose,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteDeal = `-- name: SoftDeleteDeal :exec
UPDATE deal
SET deleted_at = ?,
    updated_at = ?
WHERE id = ?
  AND workspace_id = ?
  AND deleted_at IS NULL
`

type SoftDeleteDealParams struct {
	DeletedAt   *string `db:"deleted_at" json:"deletedAt"`
	UpdatedAt   string  `db:"updated_at" json:"updatedAt"`
	ID          string  `db:"id" json:"id"`
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) SoftDeleteDeal(ctx context.Context, arg SoftDeleteDealParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteDeal,
		arg.DeletedAt,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}

const sumDealAmountByPipeline = `-- name: SumDealAmountByPipeline :one
SELECT COALESCE(SUM(amount), 0) FROM deal
WHERE workspace_id = ?
  AND pipeline_id = ?
  AND status = 'open'
  AND deleted_at IS NULL
`

type SumDealAmountByPipelineParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	PipelineID  string `db:"pipeline_id" json:"pipelineId"`
}

func (q *Queries) SumDealAmountByPipeline(ctx context.Context, arg SumDealAmountByPipelineParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, sumDealAmountByPipeline, arg.WorkspaceID, arg.PipelineID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const updateDeal = `-- name: UpdateDeal :exec
UPDATE deal
SET account_id = ?,
    contact_id = ?,
    pipeline_id = ?,
    stage_id = ?,
    owner_id = ?,
    title = ?,
    amount = ?,
    currency = ?,
    expected_close = ?,
    status = ?,
    metadata = ?,
    updated_at = ?
WHERE id = ?
  AND workspace_id = ?
  AND deleted_at IS NULL
`

type UpdateDealParams struct {
	AccountID     string   `db:"account_id" json:"accountId"`
	ContactID     *string  `db:"contact_id" json:"contactId"`
	PipelineID    string   `db:"pipeline_id" json:"pipelineId"`
	StageID       string   `db:"stage_id" json:"stageId"`
	OwnerID       string   `db:"owner_id" json:"ownerId"`
	Title         string   `db:"title" json:"title"`
	Amount        *float64 `db:"amount" json:"amount"`
	Currency      *string  `db:"currency" json:"currency"`
	ExpectedClose *string  `db:"expected_close" json:"expectedClose"`
	Status        string   `db:"status" json:"status"`
	Metadata      *string  `db:"metadata" json:"metadata"`
	UpdatedAt     string   `db:"updated_at" json:"updatedAt"`
	ID            string   `db:"id" json:"id"`
	WorkspaceID   string   `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) UpdateDeal(ctx context.Context, arg UpdateDealParams) error {
	_, err := q.db.ExecContext(ctx, updateDeal,
		arg.AccountID,
		arg.ContactID,
		arg.PipelineID,
		arg.StageID,
		arg.OwnerID,
		arg.Title,
		arg.Amount,
		arg.Currency,
		arg.ExpectedClose,
		arg.Status,
		arg.Metadata,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}
