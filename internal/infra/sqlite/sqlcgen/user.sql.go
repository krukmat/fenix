// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package sqlcgen

import (
	"context"
)

const countUsersByWorkspace = `-- name: CountUsersByWorkspace :one
?;

SELECT COUNT(*) FROM user_account
WHERE workspace_id =
`

func (q *Queries) CountUsersByWorkspace(ctx context.Context, workspaceID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsersByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :exec

INSERT INTO user_account (id, workspace_id, external_idp_id, email, password_hash, display_name, avatar_url, status, preferences, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
`

type CreateUserParams struct {
	ID            string  `db:"id" json:"id"`
	WorkspaceID   string  `db:"workspace_id" json:"workspaceId"`
	ExternalIdpID *string `db:"external_idp_id" json:"externalIdpId"`
	Email         string  `db:"email" json:"email"`
	PasswordHash  *string `db:"password_hash" json:"passwordHash"`
	DisplayName   string  `db:"display_name" json:"displayName"`
	AvatarUrl     *string `db:"avatar_url" json:"avatarUrl"`
	Status        string  `db:"status" json:"status"`
	Preferences   *string `db:"preferences" json:"preferences"`
	CreatedAt     string  `db:"created_at" json:"createdAt"`
	UpdatedAt     string  `db:"updated_at" json:"updatedAt"`
}

// SQL queries for user_account table
// Task 1.2.7: sqlc-annotated queries
// IMPORTANT: All user queries filter by workspace_id for multi-tenancy isolation.
// Note: RETURNING * not supported by sqlc SQLite parser â€” use :exec + GetByID pattern.
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.WorkspaceID,
		arg.ExternalIdpID,
		arg.Email,
		arg.PasswordHash,
		arg.DisplayName,
		arg.AvatarUrl,
		arg.Status,
		arg.Preferences,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
?;

DELETE FROM user_account
WHERE id = ?
  AND workspace_id =
`

type DeleteUserParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) DeleteUser(ctx context.Context, arg DeleteUserParams) error {
	_, err := q.db.ExecContext(ctx, deleteUser, arg.ID, arg.WorkspaceID)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
1;

SELECT id, workspace_id, external_idp_id, email, password_hash, display_name, avatar_url, status, preferences, created_at, updated_at
FROM user_account
WHERE email = ?
LIMIT
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (UserAccount, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i UserAccount
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ExternalIdpID,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Status,
		&i.Preferences,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByExternalIDP = `-- name: GetUserByExternalIDP :one
1;

SELECT id, workspace_id, external_idp_id, email, password_hash, display_name, avatar_url, status, preferences, created_at, updated_at
FROM user_account
WHERE external_idp_id = ?
LIMIT
`

func (q *Queries) GetUserByExternalIDP(ctx context.Context, externalIdpID *string) (UserAccount, error) {
	row := q.db.QueryRowContext(ctx, getUserByExternalIDP, externalIdpID)
	var i UserAccount
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ExternalIdpID,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Status,
		&i.Preferences,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
);

SELECT id, workspace_id, external_idp_id, email, password_hash, display_name, avatar_url, status, preferences, created_at, updated_at
FROM user_account
WHERE id = ?
  AND workspace_id = ?
LIMIT
`

type GetUserByIDParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) GetUserByID(ctx context.Context, arg GetUserByIDParams) (UserAccount, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, arg.ID, arg.WorkspaceID)
	var i UserAccount
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ExternalIdpID,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Status,
		&i.Preferences,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveUsersByWorkspace = `-- name: ListActiveUsersByWorkspace :many
C;

SELECT id, workspace_id, external_idp_id, email, password_hash, display_name, avatar_url, status, preferences, created_at, updated_at
FROM user_account
WHERE workspace_id = ?
  AND status = 'active'
ORDER BY display_name A
`

func (q *Queries) ListActiveUsersByWorkspace(ctx context.Context, workspaceID string) ([]UserAccount, error) {
	rows, err := q.db.QueryContext(ctx, listActiveUsersByWorkspace, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserAccount{}
	for rows.Next() {
		var i UserAccount
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ExternalIdpID,
			&i.Email,
			&i.PasswordHash,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.Status,
			&i.Preferences,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByWorkspace = `-- name: ListUsersByWorkspace :many
1;

SELECT id, workspace_id, external_idp_id, email, password_hash, display_name, avatar_url, status, preferences, created_at, updated_at
FROM user_account
WHERE workspace_id = ?
ORDER BY display_name A
`

func (q *Queries) ListUsersByWorkspace(ctx context.Context, workspaceID string) ([]UserAccount, error) {
	rows, err := q.db.QueryContext(ctx, listUsersByWorkspace, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserAccount{}
	for rows.Next() {
		var i UserAccount
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ExternalIdpID,
			&i.Email,
			&i.PasswordHash,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.Status,
			&i.Preferences,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :exec
C;

UPDATE user_account
SET display_name = ?,
    avatar_url   = ?,
    preferences  = ?,
    updated_at   = ?
WHERE id = ?
  AND workspace_id =
`

type UpdateUserParams struct {
	DisplayName string  `db:"display_name" json:"displayName"`
	AvatarUrl   *string `db:"avatar_url" json:"avatarUrl"`
	Preferences *string `db:"preferences" json:"preferences"`
	UpdatedAt   string  `db:"updated_at" json:"updatedAt"`
	ID          string  `db:"id" json:"id"`
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.DisplayName,
		arg.AvatarUrl,
		arg.Preferences,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}

const updateUserPasswordHash = `-- name: UpdateUserPasswordHash :exec
?;

UPDATE user_account
SET password_hash = ?,
    updated_at    = ?
WHERE id = ?
  AND workspace_id =
`

type UpdateUserPasswordHashParams struct {
	PasswordHash *string `db:"password_hash" json:"passwordHash"`
	UpdatedAt    string  `db:"updated_at" json:"updatedAt"`
	ID           string  `db:"id" json:"id"`
	WorkspaceID  string  `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) UpdateUserPasswordHash(ctx context.Context, arg UpdateUserPasswordHashParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPasswordHash,
		arg.PasswordHash,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}

const updateUserStatus = `-- name: UpdateUserStatus :exec
?;

UPDATE user_account
SET status     = ?,
    updated_at = ?
WHERE id = ?
  AND workspace_id =
`

type UpdateUserStatusParams struct {
	Status      string `db:"status" json:"status"`
	UpdatedAt   string `db:"updated_at" json:"updatedAt"`
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateUserStatus,
		arg.Status,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}
