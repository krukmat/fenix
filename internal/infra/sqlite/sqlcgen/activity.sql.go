// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activity.sql

package sqlcgen

import (
	"context"
)

const countActivitiesByEntity = `-- name: CountActivitiesByEntity :one
SELECT COUNT(*) FROM activity
WHERE workspace_id = ?
  AND entity_type = ?
  AND entity_id = ?
`

type CountActivitiesByEntityParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	EntityType  string `db:"entity_type" json:"entityType"`
	EntityID    string `db:"entity_id" json:"entityId"`
}

func (q *Queries) CountActivitiesByEntity(ctx context.Context, arg CountActivitiesByEntityParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivitiesByEntity, arg.WorkspaceID, arg.EntityType, arg.EntityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActivitiesByWorkspace = `-- name: CountActivitiesByWorkspace :one
SELECT COUNT(*) FROM activity
WHERE workspace_id = ?
`

func (q *Queries) CountActivitiesByWorkspace(ctx context.Context, workspaceID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivitiesByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingActivitiesByAssignee = `-- name: CountPendingActivitiesByAssignee :one
SELECT COUNT(*) FROM activity
WHERE workspace_id = ?
  AND assigned_to = ?
  AND status = 'pending'
`

type CountPendingActivitiesByAssigneeParams struct {
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
	AssignedTo  *string `db:"assigned_to" json:"assignedTo"`
}

func (q *Queries) CountPendingActivitiesByAssignee(ctx context.Context, arg CountPendingActivitiesByAssigneeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingActivitiesByAssignee, arg.WorkspaceID, arg.AssignedTo)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createActivity = `-- name: CreateActivity :exec

INSERT INTO activity (id, workspace_id, activity_type, entity_type, entity_id, owner_id, assigned_to, subject, body, status, due_at, completed_at, metadata, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateActivityParams struct {
	ID           string  `db:"id" json:"id"`
	WorkspaceID  string  `db:"workspace_id" json:"workspaceId"`
	ActivityType string  `db:"activity_type" json:"activityType"`
	EntityType   string  `db:"entity_type" json:"entityType"`
	EntityID     string  `db:"entity_id" json:"entityId"`
	OwnerID      string  `db:"owner_id" json:"ownerId"`
	AssignedTo   *string `db:"assigned_to" json:"assignedTo"`
	Subject      string  `db:"subject" json:"subject"`
	Body         *string `db:"body" json:"body"`
	Status       string  `db:"status" json:"status"`
	DueAt        *string `db:"due_at" json:"dueAt"`
	CompletedAt  *string `db:"completed_at" json:"completedAt"`
	Metadata     *string `db:"metadata" json:"metadata"`
	CreatedAt    string  `db:"created_at" json:"createdAt"`
	UpdatedAt    string  `db:"updated_at" json:"updatedAt"`
}

// SQL queries for activity table
// Task 1.5: Activity (tasks, events, calls, emails) management queries
func (q *Queries) CreateActivity(ctx context.Context, arg CreateActivityParams) error {
	_, err := q.db.ExecContext(ctx, createActivity,
		arg.ID,
		arg.WorkspaceID,
		arg.ActivityType,
		arg.EntityType,
		arg.EntityID,
		arg.OwnerID,
		arg.AssignedTo,
		arg.Subject,
		arg.Body,
		arg.Status,
		arg.DueAt,
		arg.CompletedAt,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteActivity = `-- name: DeleteActivity :exec
DELETE FROM activity
WHERE id = ?
  AND workspace_id = ?
`

type DeleteActivityParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) DeleteActivity(ctx context.Context, arg DeleteActivityParams) error {
	_, err := q.db.ExecContext(ctx, deleteActivity, arg.ID, arg.WorkspaceID)
	return err
}

const getActivityByID = `-- name: GetActivityByID :one
SELECT id, workspace_id, activity_type, entity_type, entity_id, owner_id, assigned_to, subject, body, status, due_at, completed_at, metadata, created_at, updated_at
FROM activity
WHERE id = ?
  AND workspace_id = ?
LIMIT 1
`

type GetActivityByIDParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) GetActivityByID(ctx context.Context, arg GetActivityByIDParams) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getActivityByID, arg.ID, arg.WorkspaceID)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ActivityType,
		&i.EntityType,
		&i.EntityID,
		&i.OwnerID,
		&i.AssignedTo,
		&i.Subject,
		&i.Body,
		&i.Status,
		&i.DueAt,
		&i.CompletedAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActivitiesByAssignee = `-- name: ListActivitiesByAssignee :many
SELECT id, workspace_id, activity_type, entity_type, entity_id, owner_id, assigned_to, subject, body, status, due_at, completed_at, metadata, created_at, updated_at
FROM activity
WHERE workspace_id = ?
  AND assigned_to = ?
ORDER BY
  CASE status
    WHEN 'pending' THEN 1
    WHEN 'completed' THEN 2
    WHEN 'cancelled' THEN 3
  END,
  due_at ASC NULLS LAST,
  created_at DESC
`

type ListActivitiesByAssigneeParams struct {
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
	AssignedTo  *string `db:"assigned_to" json:"assignedTo"`
}

func (q *Queries) ListActivitiesByAssignee(ctx context.Context, arg ListActivitiesByAssigneeParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, listActivitiesByAssignee, arg.WorkspaceID, arg.AssignedTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActivityType,
			&i.EntityType,
			&i.EntityID,
			&i.OwnerID,
			&i.AssignedTo,
			&i.Subject,
			&i.Body,
			&i.Status,
			&i.DueAt,
			&i.CompletedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivitiesByEntity = `-- name: ListActivitiesByEntity :many
SELECT id, workspace_id, activity_type, entity_type, entity_id, owner_id, assigned_to, subject, body, status, due_at, completed_at, metadata, created_at, updated_at
FROM activity
WHERE workspace_id = ?
  AND entity_type = ?
  AND entity_id = ?
ORDER BY created_at DESC
`

type ListActivitiesByEntityParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	EntityType  string `db:"entity_type" json:"entityType"`
	EntityID    string `db:"entity_id" json:"entityId"`
}

func (q *Queries) ListActivitiesByEntity(ctx context.Context, arg ListActivitiesByEntityParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, listActivitiesByEntity, arg.WorkspaceID, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActivityType,
			&i.EntityType,
			&i.EntityID,
			&i.OwnerID,
			&i.AssignedTo,
			&i.Subject,
			&i.Body,
			&i.Status,
			&i.DueAt,
			&i.CompletedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivitiesByOwner = `-- name: ListActivitiesByOwner :many
SELECT id, workspace_id, activity_type, entity_type, entity_id, owner_id, assigned_to, subject, body, status, due_at, completed_at, metadata, created_at, updated_at
FROM activity
WHERE workspace_id = ?
  AND owner_id = ?
ORDER BY created_at DESC
`

type ListActivitiesByOwnerParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	OwnerID     string `db:"owner_id" json:"ownerId"`
}

func (q *Queries) ListActivitiesByOwner(ctx context.Context, arg ListActivitiesByOwnerParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, listActivitiesByOwner, arg.WorkspaceID, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActivityType,
			&i.EntityType,
			&i.EntityID,
			&i.OwnerID,
			&i.AssignedTo,
			&i.Subject,
			&i.Body,
			&i.Status,
			&i.DueAt,
			&i.CompletedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivitiesByStatus = `-- name: ListActivitiesByStatus :many
SELECT id, workspace_id, activity_type, entity_type, entity_id, owner_id, assigned_to, subject, body, status, due_at, completed_at, metadata, created_at, updated_at
FROM activity
WHERE workspace_id = ?
  AND status = ?
ORDER BY created_at DESC
`

type ListActivitiesByStatusParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Status      string `db:"status" json:"status"`
}

func (q *Queries) ListActivitiesByStatus(ctx context.Context, arg ListActivitiesByStatusParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, listActivitiesByStatus, arg.WorkspaceID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActivityType,
			&i.EntityType,
			&i.EntityID,
			&i.OwnerID,
			&i.AssignedTo,
			&i.Subject,
			&i.Body,
			&i.Status,
			&i.DueAt,
			&i.CompletedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivitiesByType = `-- name: ListActivitiesByType :many
SELECT id, workspace_id, activity_type, entity_type, entity_id, owner_id, assigned_to, subject, body, status, due_at, completed_at, metadata, created_at, updated_at
FROM activity
WHERE workspace_id = ?
  AND activity_type = ?
ORDER BY created_at DESC
`

type ListActivitiesByTypeParams struct {
	WorkspaceID  string `db:"workspace_id" json:"workspaceId"`
	ActivityType string `db:"activity_type" json:"activityType"`
}

func (q *Queries) ListActivitiesByType(ctx context.Context, arg ListActivitiesByTypeParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, listActivitiesByType, arg.WorkspaceID, arg.ActivityType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActivityType,
			&i.EntityType,
			&i.EntityID,
			&i.OwnerID,
			&i.AssignedTo,
			&i.Subject,
			&i.Body,
			&i.Status,
			&i.DueAt,
			&i.CompletedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivitiesByWorkspace = `-- name: ListActivitiesByWorkspace :many
SELECT id, workspace_id, activity_type, entity_type, entity_id, owner_id, assigned_to, subject, body, status, due_at, completed_at, metadata, created_at, updated_at
FROM activity
WHERE workspace_id = ?
ORDER BY created_at DESC
LIMIT ?
OFFSET ?
`

type ListActivitiesByWorkspaceParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

func (q *Queries) ListActivitiesByWorkspace(ctx context.Context, arg ListActivitiesByWorkspaceParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, listActivitiesByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActivityType,
			&i.EntityType,
			&i.EntityID,
			&i.OwnerID,
			&i.AssignedTo,
			&i.Subject,
			&i.Body,
			&i.Status,
			&i.DueAt,
			&i.CompletedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingActivitiesByAssignee = `-- name: ListPendingActivitiesByAssignee :many
SELECT id, workspace_id, activity_type, entity_type, entity_id, owner_id, assigned_to, subject, body, status, due_at, completed_at, metadata, created_at, updated_at
FROM activity
WHERE workspace_id = ?
  AND assigned_to = ?
  AND status = 'pending'
ORDER BY
  CASE WHEN due_at < datetime('now') THEN 0 ELSE 1 END,
  due_at ASC NULLS LAST
`

type ListPendingActivitiesByAssigneeParams struct {
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
	AssignedTo  *string `db:"assigned_to" json:"assignedTo"`
}

func (q *Queries) ListPendingActivitiesByAssignee(ctx context.Context, arg ListPendingActivitiesByAssigneeParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, listPendingActivitiesByAssignee, arg.WorkspaceID, arg.AssignedTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ActivityType,
			&i.EntityType,
			&i.EntityID,
			&i.OwnerID,
			&i.AssignedTo,
			&i.Subject,
			&i.Body,
			&i.Status,
			&i.DueAt,
			&i.CompletedAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateActivity = `-- name: UpdateActivity :exec
UPDATE activity
SET activity_type = ?,
    entity_type = ?,
    entity_id = ?,
    owner_id = ?,
    assigned_to = ?,
    subject = ?,
    body = ?,
    status = ?,
    due_at = ?,
    completed_at = ?,
    metadata = ?,
    updated_at = ?
WHERE id = ?
  AND workspace_id = ?
`

type UpdateActivityParams struct {
	ActivityType string  `db:"activity_type" json:"activityType"`
	EntityType   string  `db:"entity_type" json:"entityType"`
	EntityID     string  `db:"entity_id" json:"entityId"`
	OwnerID      string  `db:"owner_id" json:"ownerId"`
	AssignedTo   *string `db:"assigned_to" json:"assignedTo"`
	Subject      string  `db:"subject" json:"subject"`
	Body         *string `db:"body" json:"body"`
	Status       string  `db:"status" json:"status"`
	DueAt        *string `db:"due_at" json:"dueAt"`
	CompletedAt  *string `db:"completed_at" json:"completedAt"`
	Metadata     *string `db:"metadata" json:"metadata"`
	UpdatedAt    string  `db:"updated_at" json:"updatedAt"`
	ID           string  `db:"id" json:"id"`
	WorkspaceID  string  `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) UpdateActivity(ctx context.Context, arg UpdateActivityParams) error {
	_, err := q.db.ExecContext(ctx, updateActivity,
		arg.ActivityType,
		arg.EntityType,
		arg.EntityID,
		arg.OwnerID,
		arg.AssignedTo,
		arg.Subject,
		arg.Body,
		arg.Status,
		arg.DueAt,
		arg.CompletedAt,
		arg.Metadata,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}
