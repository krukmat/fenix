// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: lead.sql

package sqlcgen

import (
	"context"
)

const countLeadsByStatus = `-- name: CountLeadsByStatus :one
SELECT COUNT(*) FROM lead
WHERE workspace_id = ?
  AND status = ?
  AND deleted_at IS NULL
`

type CountLeadsByStatusParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Status      string `db:"status" json:"status"`
}

func (q *Queries) CountLeadsByStatus(ctx context.Context, arg CountLeadsByStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLeadsByStatus, arg.WorkspaceID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLeadsByWorkspace = `-- name: CountLeadsByWorkspace :one
SELECT COUNT(*) FROM lead
WHERE workspace_id = ?
  AND deleted_at IS NULL
`

func (q *Queries) CountLeadsByWorkspace(ctx context.Context, workspaceID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLeadsByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLead = `-- name: CreateLead :exec

INSERT INTO lead (id, workspace_id, contact_id, account_id, source, status, owner_id, score, metadata, created_at, updated_at, deleted_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateLeadParams struct {
	ID          string   `db:"id" json:"id"`
	WorkspaceID string   `db:"workspace_id" json:"workspaceId"`
	ContactID   *string  `db:"contact_id" json:"contactId"`
	AccountID   *string  `db:"account_id" json:"accountId"`
	Source      *string  `db:"source" json:"source"`
	Status      string   `db:"status" json:"status"`
	OwnerID     string   `db:"owner_id" json:"ownerId"`
	Score       *float64 `db:"score" json:"score"`
	Metadata    *string  `db:"metadata" json:"metadata"`
	CreatedAt   string   `db:"created_at" json:"createdAt"`
	UpdatedAt   string   `db:"updated_at" json:"updatedAt"`
	DeletedAt   *string  `db:"deleted_at" json:"deletedAt"`
}

// SQL queries for lead table
// Task 1.5: Lead management queries
func (q *Queries) CreateLead(ctx context.Context, arg CreateLeadParams) error {
	_, err := q.db.ExecContext(ctx, createLead,
		arg.ID,
		arg.WorkspaceID,
		arg.ContactID,
		arg.AccountID,
		arg.Source,
		arg.Status,
		arg.OwnerID,
		arg.Score,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}

const getLeadByID = `-- name: GetLeadByID :one
SELECT id, workspace_id, contact_id, account_id, source, status, owner_id, score, metadata, created_at, updated_at, deleted_at
FROM lead
WHERE id = ?
  AND workspace_id = ?
  AND deleted_at IS NULL
LIMIT 1
`

type GetLeadByIDParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) GetLeadByID(ctx context.Context, arg GetLeadByIDParams) (Lead, error) {
	row := q.db.QueryRowContext(ctx, getLeadByID, arg.ID, arg.WorkspaceID)
	var i Lead
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ContactID,
		&i.AccountID,
		&i.Source,
		&i.Status,
		&i.OwnerID,
		&i.Score,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listLeadsByAccount = `-- name: ListLeadsByAccount :many
SELECT id, workspace_id, contact_id, account_id, source, status, owner_id, score, metadata, created_at, updated_at, deleted_at
FROM lead
WHERE workspace_id = ?
  AND account_id = ?
  AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListLeadsByAccountParams struct {
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
	AccountID   *string `db:"account_id" json:"accountId"`
}

func (q *Queries) ListLeadsByAccount(ctx context.Context, arg ListLeadsByAccountParams) ([]Lead, error) {
	rows, err := q.db.QueryContext(ctx, listLeadsByAccount, arg.WorkspaceID, arg.AccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lead{}
	for rows.Next() {
		var i Lead
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ContactID,
			&i.AccountID,
			&i.Source,
			&i.Status,
			&i.OwnerID,
			&i.Score,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadsByOwner = `-- name: ListLeadsByOwner :many
SELECT id, workspace_id, contact_id, account_id, source, status, owner_id, score, metadata, created_at, updated_at, deleted_at
FROM lead
WHERE workspace_id = ?
  AND owner_id = ?
  AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListLeadsByOwnerParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	OwnerID     string `db:"owner_id" json:"ownerId"`
}

func (q *Queries) ListLeadsByOwner(ctx context.Context, arg ListLeadsByOwnerParams) ([]Lead, error) {
	rows, err := q.db.QueryContext(ctx, listLeadsByOwner, arg.WorkspaceID, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lead{}
	for rows.Next() {
		var i Lead
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ContactID,
			&i.AccountID,
			&i.Source,
			&i.Status,
			&i.OwnerID,
			&i.Score,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadsByStatus = `-- name: ListLeadsByStatus :many
SELECT id, workspace_id, contact_id, account_id, source, status, owner_id, score, metadata, created_at, updated_at, deleted_at
FROM lead
WHERE workspace_id = ?
  AND status = ?
  AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListLeadsByStatusParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Status      string `db:"status" json:"status"`
}

func (q *Queries) ListLeadsByStatus(ctx context.Context, arg ListLeadsByStatusParams) ([]Lead, error) {
	rows, err := q.db.QueryContext(ctx, listLeadsByStatus, arg.WorkspaceID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lead{}
	for rows.Next() {
		var i Lead
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ContactID,
			&i.AccountID,
			&i.Source,
			&i.Status,
			&i.OwnerID,
			&i.Score,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLeadsByWorkspace = `-- name: ListLeadsByWorkspace :many
SELECT id, workspace_id, contact_id, account_id, source, status, owner_id, score, metadata, created_at, updated_at, deleted_at
FROM lead
WHERE workspace_id = ?
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT ?
OFFSET ?
`

type ListLeadsByWorkspaceParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

func (q *Queries) ListLeadsByWorkspace(ctx context.Context, arg ListLeadsByWorkspaceParams) ([]Lead, error) {
	rows, err := q.db.QueryContext(ctx, listLeadsByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lead{}
	for rows.Next() {
		var i Lead
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ContactID,
			&i.AccountID,
			&i.Source,
			&i.Status,
			&i.OwnerID,
			&i.Score,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteLead = `-- name: SoftDeleteLead :exec
UPDATE lead
SET deleted_at = ?,
    updated_at = ?
WHERE id = ?
  AND workspace_id = ?
  AND deleted_at IS NULL
`

type SoftDeleteLeadParams struct {
	DeletedAt   *string `db:"deleted_at" json:"deletedAt"`
	UpdatedAt   string  `db:"updated_at" json:"updatedAt"`
	ID          string  `db:"id" json:"id"`
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) SoftDeleteLead(ctx context.Context, arg SoftDeleteLeadParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteLead,
		arg.DeletedAt,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}

const updateLead = `-- name: UpdateLead :exec
UPDATE lead
SET contact_id = ?,
    account_id = ?,
    source = ?,
    status = ?,
    owner_id = ?,
    score = ?,
    metadata = ?,
    updated_at = ?
WHERE id = ?
  AND workspace_id = ?
  AND deleted_at IS NULL
`

type UpdateLeadParams struct {
	ContactID   *string  `db:"contact_id" json:"contactId"`
	AccountID   *string  `db:"account_id" json:"accountId"`
	Source      *string  `db:"source" json:"source"`
	Status      string   `db:"status" json:"status"`
	OwnerID     string   `db:"owner_id" json:"ownerId"`
	Score       *float64 `db:"score" json:"score"`
	Metadata    *string  `db:"metadata" json:"metadata"`
	UpdatedAt   string   `db:"updated_at" json:"updatedAt"`
	ID          string   `db:"id" json:"id"`
	WorkspaceID string   `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) UpdateLead(ctx context.Context, arg UpdateLeadParams) error {
	_, err := q.db.ExecContext(ctx, updateLead,
		arg.ContactID,
		arg.AccountID,
		arg.Source,
		arg.Status,
		arg.OwnerID,
		arg.Score,
		arg.Metadata,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}
