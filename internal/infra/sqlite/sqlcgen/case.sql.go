// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: case.sql

package sqlcgen

import (
	"context"
)

const countCasesByStatus = `-- name: CountCasesByStatus :one
SELECT COUNT(*) FROM case_ticket
WHERE workspace_id = ?
  AND status = ?
  AND deleted_at IS NULL
`

type CountCasesByStatusParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Status      string `db:"status" json:"status"`
}

func (q *Queries) CountCasesByStatus(ctx context.Context, arg CountCasesByStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCasesByStatus, arg.WorkspaceID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCasesByWorkspace = `-- name: CountCasesByWorkspace :one
SELECT COUNT(*) FROM case_ticket
WHERE workspace_id = ?
  AND deleted_at IS NULL
`

func (q *Queries) CountCasesByWorkspace(ctx context.Context, workspaceID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCasesByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOverdueCases = `-- name: CountOverdueCases :one
SELECT COUNT(*) FROM case_ticket
WHERE workspace_id = ?
  AND sla_deadline < datetime('now')
  AND deleted_at IS NULL
  AND status IN ('open', 'in_progress', 'waiting')
`

func (q *Queries) CountOverdueCases(ctx context.Context, workspaceID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOverdueCases, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCase = `-- name: CreateCase :exec

INSERT INTO case_ticket (id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, subject, description, priority, status, channel, sla_config, sla_deadline, metadata, created_at, updated_at, deleted_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateCaseParams struct {
	ID          string  `db:"id" json:"id"`
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
	AccountID   *string `db:"account_id" json:"accountId"`
	ContactID   *string `db:"contact_id" json:"contactId"`
	PipelineID  *string `db:"pipeline_id" json:"pipelineId"`
	StageID     *string `db:"stage_id" json:"stageId"`
	OwnerID     string  `db:"owner_id" json:"ownerId"`
	Subject     string  `db:"subject" json:"subject"`
	Description *string `db:"description" json:"description"`
	Priority    string  `db:"priority" json:"priority"`
	Status      string  `db:"status" json:"status"`
	Channel     *string `db:"channel" json:"channel"`
	SlaConfig   *string `db:"sla_config" json:"slaConfig"`
	SlaDeadline *string `db:"sla_deadline" json:"slaDeadline"`
	Metadata    *string `db:"metadata" json:"metadata"`
	CreatedAt   string  `db:"created_at" json:"createdAt"`
	UpdatedAt   string  `db:"updated_at" json:"updatedAt"`
	DeletedAt   *string `db:"deleted_at" json:"deletedAt"`
}

// SQL queries for case_ticket table
// Task 1.5: Case/Support ticket management queries
func (q *Queries) CreateCase(ctx context.Context, arg CreateCaseParams) error {
	_, err := q.db.ExecContext(ctx, createCase,
		arg.ID,
		arg.WorkspaceID,
		arg.AccountID,
		arg.ContactID,
		arg.PipelineID,
		arg.StageID,
		arg.OwnerID,
		arg.Subject,
		arg.Description,
		arg.Priority,
		arg.Status,
		arg.Channel,
		arg.SlaConfig,
		arg.SlaDeadline,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}

const getCaseByID = `-- name: GetCaseByID :one
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, subject, description, priority, status, channel, sla_config, sla_deadline, metadata, created_at, updated_at, deleted_at
FROM case_ticket
WHERE id = ?
  AND workspace_id = ?
  AND deleted_at IS NULL
LIMIT 1
`

type GetCaseByIDParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) GetCaseByID(ctx context.Context, arg GetCaseByIDParams) (CaseTicket, error) {
	row := q.db.QueryRowContext(ctx, getCaseByID, arg.ID, arg.WorkspaceID)
	var i CaseTicket
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.AccountID,
		&i.ContactID,
		&i.PipelineID,
		&i.StageID,
		&i.OwnerID,
		&i.Subject,
		&i.Description,
		&i.Priority,
		&i.Status,
		&i.Channel,
		&i.SlaConfig,
		&i.SlaDeadline,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listCasesByAccount = `-- name: ListCasesByAccount :many
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, subject, description, priority, status, channel, sla_config, sla_deadline, metadata, created_at, updated_at, deleted_at
FROM case_ticket
WHERE workspace_id = ?
  AND account_id = ?
  AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListCasesByAccountParams struct {
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
	AccountID   *string `db:"account_id" json:"accountId"`
}

func (q *Queries) ListCasesByAccount(ctx context.Context, arg ListCasesByAccountParams) ([]CaseTicket, error) {
	rows, err := q.db.QueryContext(ctx, listCasesByAccount, arg.WorkspaceID, arg.AccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseTicket{}
	for rows.Next() {
		var i CaseTicket
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.ContactID,
			&i.PipelineID,
			&i.StageID,
			&i.OwnerID,
			&i.Subject,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.Channel,
			&i.SlaConfig,
			&i.SlaDeadline,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCasesByOwner = `-- name: ListCasesByOwner :many
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, subject, description, priority, status, channel, sla_config, sla_deadline, metadata, created_at, updated_at, deleted_at
FROM case_ticket
WHERE workspace_id = ?
  AND owner_id = ?
  AND deleted_at IS NULL
ORDER BY
  CASE priority
    WHEN 'critical' THEN 1
    WHEN 'high' THEN 2
    WHEN 'medium' THEN 3
    WHEN 'low' THEN 4
  END,
  created_at DESC
`

type ListCasesByOwnerParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	OwnerID     string `db:"owner_id" json:"ownerId"`
}

func (q *Queries) ListCasesByOwner(ctx context.Context, arg ListCasesByOwnerParams) ([]CaseTicket, error) {
	rows, err := q.db.QueryContext(ctx, listCasesByOwner, arg.WorkspaceID, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseTicket{}
	for rows.Next() {
		var i CaseTicket
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.ContactID,
			&i.PipelineID,
			&i.StageID,
			&i.OwnerID,
			&i.Subject,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.Channel,
			&i.SlaConfig,
			&i.SlaDeadline,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCasesBySLADeadline = `-- name: ListCasesBySLADeadline :many
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, subject, description, priority, status, channel, sla_config, sla_deadline, metadata, created_at, updated_at, deleted_at
FROM case_ticket
WHERE workspace_id = ?
  AND sla_deadline IS NOT NULL
  AND deleted_at IS NULL
  AND status IN ('open', 'in_progress', 'waiting')
ORDER BY sla_deadline ASC
LIMIT ?
`

type ListCasesBySLADeadlineParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Limit       int64  `db:"limit" json:"limit"`
}

func (q *Queries) ListCasesBySLADeadline(ctx context.Context, arg ListCasesBySLADeadlineParams) ([]CaseTicket, error) {
	rows, err := q.db.QueryContext(ctx, listCasesBySLADeadline, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseTicket{}
	for rows.Next() {
		var i CaseTicket
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.ContactID,
			&i.PipelineID,
			&i.StageID,
			&i.OwnerID,
			&i.Subject,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.Channel,
			&i.SlaConfig,
			&i.SlaDeadline,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCasesByStatus = `-- name: ListCasesByStatus :many
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, subject, description, priority, status, channel, sla_config, sla_deadline, metadata, created_at, updated_at, deleted_at
FROM case_ticket
WHERE workspace_id = ?
  AND status = ?
  AND deleted_at IS NULL
ORDER BY
  CASE priority
    WHEN 'critical' THEN 1
    WHEN 'high' THEN 2
    WHEN 'medium' THEN 3
    WHEN 'low' THEN 4
  END,
  created_at DESC
`

type ListCasesByStatusParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Status      string `db:"status" json:"status"`
}

func (q *Queries) ListCasesByStatus(ctx context.Context, arg ListCasesByStatusParams) ([]CaseTicket, error) {
	rows, err := q.db.QueryContext(ctx, listCasesByStatus, arg.WorkspaceID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseTicket{}
	for rows.Next() {
		var i CaseTicket
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.ContactID,
			&i.PipelineID,
			&i.StageID,
			&i.OwnerID,
			&i.Subject,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.Channel,
			&i.SlaConfig,
			&i.SlaDeadline,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCasesByWorkspace = `-- name: ListCasesByWorkspace :many
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, subject, description, priority, status, channel, sla_config, sla_deadline, metadata, created_at, updated_at, deleted_at
FROM case_ticket
WHERE workspace_id = ?
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT ?
OFFSET ?
`

type ListCasesByWorkspaceParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

func (q *Queries) ListCasesByWorkspace(ctx context.Context, arg ListCasesByWorkspaceParams) ([]CaseTicket, error) {
	rows, err := q.db.QueryContext(ctx, listCasesByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseTicket{}
	for rows.Next() {
		var i CaseTicket
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.ContactID,
			&i.PipelineID,
			&i.StageID,
			&i.OwnerID,
			&i.Subject,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.Channel,
			&i.SlaConfig,
			&i.SlaDeadline,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenCasesByPriority = `-- name: ListOpenCasesByPriority :many
SELECT id, workspace_id, account_id, contact_id, pipeline_id, stage_id, owner_id, subject, description, priority, status, channel, sla_config, sla_deadline, metadata, created_at, updated_at, deleted_at
FROM case_ticket
WHERE workspace_id = ?
  AND deleted_at IS NULL
  AND status IN ('open', 'in_progress', 'waiting')
ORDER BY
  CASE priority
    WHEN 'critical' THEN 1
    WHEN 'high' THEN 2
    WHEN 'medium' THEN 3
    WHEN 'low' THEN 4
  END,
  created_at DESC
`

func (q *Queries) ListOpenCasesByPriority(ctx context.Context, workspaceID string) ([]CaseTicket, error) {
	rows, err := q.db.QueryContext(ctx, listOpenCasesByPriority, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CaseTicket{}
	for rows.Next() {
		var i CaseTicket
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.ContactID,
			&i.PipelineID,
			&i.StageID,
			&i.OwnerID,
			&i.Subject,
			&i.Description,
			&i.Priority,
			&i.Status,
			&i.Channel,
			&i.SlaConfig,
			&i.SlaDeadline,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteCase = `-- name: SoftDeleteCase :exec
UPDATE case_ticket
SET deleted_at = ?,
    updated_at = ?
WHERE id = ?
  AND workspace_id = ?
  AND deleted_at IS NULL
`

type SoftDeleteCaseParams struct {
	DeletedAt   *string `db:"deleted_at" json:"deletedAt"`
	UpdatedAt   string  `db:"updated_at" json:"updatedAt"`
	ID          string  `db:"id" json:"id"`
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) SoftDeleteCase(ctx context.Context, arg SoftDeleteCaseParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteCase,
		arg.DeletedAt,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}

const updateCase = `-- name: UpdateCase :exec
UPDATE case_ticket
SET account_id = ?,
    contact_id = ?,
    pipeline_id = ?,
    stage_id = ?,
    owner_id = ?,
    subject = ?,
    description = ?,
    priority = ?,
    status = ?,
    channel = ?,
    sla_config = ?,
    sla_deadline = ?,
    metadata = ?,
    updated_at = ?
WHERE id = ?
  AND workspace_id = ?
  AND deleted_at IS NULL
`

type UpdateCaseParams struct {
	AccountID   *string `db:"account_id" json:"accountId"`
	ContactID   *string `db:"contact_id" json:"contactId"`
	PipelineID  *string `db:"pipeline_id" json:"pipelineId"`
	StageID     *string `db:"stage_id" json:"stageId"`
	OwnerID     string  `db:"owner_id" json:"ownerId"`
	Subject     string  `db:"subject" json:"subject"`
	Description *string `db:"description" json:"description"`
	Priority    string  `db:"priority" json:"priority"`
	Status      string  `db:"status" json:"status"`
	Channel     *string `db:"channel" json:"channel"`
	SlaConfig   *string `db:"sla_config" json:"slaConfig"`
	SlaDeadline *string `db:"sla_deadline" json:"slaDeadline"`
	Metadata    *string `db:"metadata" json:"metadata"`
	UpdatedAt   string  `db:"updated_at" json:"updatedAt"`
	ID          string  `db:"id" json:"id"`
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
}

func (q *Queries) UpdateCase(ctx context.Context, arg UpdateCaseParams) error {
	_, err := q.db.ExecContext(ctx, updateCase,
		arg.AccountID,
		arg.ContactID,
		arg.PipelineID,
		arg.StageID,
		arg.OwnerID,
		arg.Subject,
		arg.Description,
		arg.Priority,
		arg.Status,
		arg.Channel,
		arg.SlaConfig,
		arg.SlaDeadline,
		arg.Metadata,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}
