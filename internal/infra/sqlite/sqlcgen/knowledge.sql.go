// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: knowledge.sql

package sqlcgen

import (
	"context"
	"time"
)

const countKnowledgeItemsByWorkspace = `-- name: CountKnowledgeItemsByWorkspace :one
SELECT COUNT(*) FROM knowledge_item
WHERE workspace_id = ? AND deleted_at IS NULL
`

// Task 2.2: Count total knowledge items for a workspace
func (q *Queries) CountKnowledgeItemsByWorkspace(ctx context.Context, workspaceID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countKnowledgeItemsByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingEmbeddingsByWorkspace = `-- name: CountPendingEmbeddingsByWorkspace :one
SELECT COUNT(*) FROM embedding_document
WHERE workspace_id = ? AND embedding_status = 'pending'
`

// Task 2.4/2.7: Count pending embeddings for a workspace
func (q *Queries) CountPendingEmbeddingsByWorkspace(ctx context.Context, workspaceID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingEmbeddingsByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEmbeddingDocument = `-- name: CreateEmbeddingDocument :exec

INSERT INTO embedding_document (
    id, knowledge_item_id, workspace_id, chunk_index,
    chunk_text, token_count, embedding_status, created_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateEmbeddingDocumentParams struct {
	ID              string    `db:"id" json:"id"`
	KnowledgeItemID string    `db:"knowledge_item_id" json:"knowledgeItemId"`
	WorkspaceID     string    `db:"workspace_id" json:"workspaceId"`
	ChunkIndex      int64     `db:"chunk_index" json:"chunkIndex"`
	ChunkText       string    `db:"chunk_text" json:"chunkText"`
	TokenCount      *int64    `db:"token_count" json:"tokenCount"`
	EmbeddingStatus string    `db:"embedding_status" json:"embeddingStatus"`
	CreatedAt       time.Time `db:"created_at" json:"createdAt"`
}

// ============================================================================
// EMBEDDING DOCUMENT QUERIES
// ============================================================================
// Task 2.2/2.4: Insert a chunk with pending embedding status
func (q *Queries) CreateEmbeddingDocument(ctx context.Context, arg CreateEmbeddingDocumentParams) error {
	_, err := q.db.ExecContext(ctx, createEmbeddingDocument,
		arg.ID,
		arg.KnowledgeItemID,
		arg.WorkspaceID,
		arg.ChunkIndex,
		arg.ChunkText,
		arg.TokenCount,
		arg.EmbeddingStatus,
		arg.CreatedAt,
	)
	return err
}

const createEvidence = `-- name: CreateEvidence :exec

INSERT INTO evidence (
    id, knowledge_item_id, workspace_id, method,
    score, snippet, pii_redacted, metadata, created_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateEvidenceParams struct {
	ID              string    `db:"id" json:"id"`
	KnowledgeItemID string    `db:"knowledge_item_id" json:"knowledgeItemId"`
	WorkspaceID     string    `db:"workspace_id" json:"workspaceId"`
	Method          string    `db:"method" json:"method"`
	Score           float64   `db:"score" json:"score"`
	Snippet         *string   `db:"snippet" json:"snippet"`
	PiiRedacted     bool      `db:"pii_redacted" json:"piiRedacted"`
	Metadata        *string   `db:"metadata" json:"metadata"`
	CreatedAt       time.Time `db:"created_at" json:"createdAt"`
}

// ============================================================================
// EVIDENCE QUERIES
// ============================================================================
// Task 2.6: Store a search result snapshot
func (q *Queries) CreateEvidence(ctx context.Context, arg CreateEvidenceParams) error {
	_, err := q.db.ExecContext(ctx, createEvidence,
		arg.ID,
		arg.KnowledgeItemID,
		arg.WorkspaceID,
		arg.Method,
		arg.Score,
		arg.Snippet,
		arg.PiiRedacted,
		arg.Metadata,
		arg.CreatedAt,
	)
	return err
}

const createKnowledgeItem = `-- name: CreateKnowledgeItem :exec


INSERT INTO knowledge_item (
    id, workspace_id, source_type, title, raw_content,
    normalized_content, entity_type, entity_id, metadata,
    created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateKnowledgeItemParams struct {
	ID                string    `db:"id" json:"id"`
	WorkspaceID       string    `db:"workspace_id" json:"workspaceId"`
	SourceType        string    `db:"source_type" json:"sourceType"`
	Title             string    `db:"title" json:"title"`
	RawContent        string    `db:"raw_content" json:"rawContent"`
	NormalizedContent *string   `db:"normalized_content" json:"normalizedContent"`
	EntityType        *string   `db:"entity_type" json:"entityType"`
	EntityID          *string   `db:"entity_id" json:"entityId"`
	Metadata          *string   `db:"metadata" json:"metadata"`
	CreatedAt         time.Time `db:"created_at" json:"createdAt"`
	UpdatedAt         time.Time `db:"updated_at" json:"updatedAt"`
}

// Queries for knowledge layer tables
// Related to: Task 2.1, internal/domain/knowledge
// SECURITY NOTE: All queries include workspace_id filter to enforce multi-tenant isolation.
// Vector search (vec_embedding) is NOT handled here - modernc.org/sqlite requires
// raw sql.DB queries for virtual tables. See Task 2.5 for safe vector query patterns.
// ============================================================================
// KNOWLEDGE ITEM QUERIES
// ============================================================================
// Task 2.1/2.2: Insert a new knowledge item
func (q *Queries) CreateKnowledgeItem(ctx context.Context, arg CreateKnowledgeItemParams) error {
	_, err := q.db.ExecContext(ctx, createKnowledgeItem,
		arg.ID,
		arg.WorkspaceID,
		arg.SourceType,
		arg.Title,
		arg.RawContent,
		arg.NormalizedContent,
		arg.EntityType,
		arg.EntityID,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteEmbeddingDocumentsByKnowledgeItem = `-- name: DeleteEmbeddingDocumentsByKnowledgeItem :exec
DELETE FROM embedding_document
WHERE knowledge_item_id = ? AND workspace_id = ?
`

type DeleteEmbeddingDocumentsByKnowledgeItemParams struct {
	KnowledgeItemID string `db:"knowledge_item_id" json:"knowledgeItemId"`
	WorkspaceID     string `db:"workspace_id" json:"workspaceId"`
}

// Task 2.7: Remove all chunks when knowledge item is deleted/reindexed
func (q *Queries) DeleteEmbeddingDocumentsByKnowledgeItem(ctx context.Context, arg DeleteEmbeddingDocumentsByKnowledgeItemParams) error {
	_, err := q.db.ExecContext(ctx, deleteEmbeddingDocumentsByKnowledgeItem, arg.KnowledgeItemID, arg.WorkspaceID)
	return err
}

const deleteVecEmbeddingsByKnowledgeItem = `-- name: DeleteVecEmbeddingsByKnowledgeItem :exec
DELETE FROM vec_embedding
WHERE id IN (
    SELECT ed.id FROM embedding_document ed
    WHERE ed.knowledge_item_id = ? AND ed.workspace_id = ?
)
`

type DeleteVecEmbeddingsByKnowledgeItemParams struct {
	KnowledgeItemID string `db:"knowledge_item_id" json:"knowledgeItemId"`
	WorkspaceID     string `db:"workspace_id" json:"workspaceId"`
}

// Task 2.4: Remove vectors for all chunks of a knowledge_item (on re-ingest).
func (q *Queries) DeleteVecEmbeddingsByKnowledgeItem(ctx context.Context, arg DeleteVecEmbeddingsByKnowledgeItemParams) error {
	_, err := q.db.ExecContext(ctx, deleteVecEmbeddingsByKnowledgeItem, arg.KnowledgeItemID, arg.WorkspaceID)
	return err
}

const getEmbeddingDocumentByID = `-- name: GetEmbeddingDocumentByID :one
SELECT id, knowledge_item_id, workspace_id, chunk_index, chunk_text, token_count, embedding_status, embedded_at, created_at FROM embedding_document
WHERE id = ? AND workspace_id = ?
LIMIT 1
`

type GetEmbeddingDocumentByIDParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

// Task 2.4: Get a single embedding document
func (q *Queries) GetEmbeddingDocumentByID(ctx context.Context, arg GetEmbeddingDocumentByIDParams) (EmbeddingDocument, error) {
	row := q.db.QueryRowContext(ctx, getEmbeddingDocumentByID, arg.ID, arg.WorkspaceID)
	var i EmbeddingDocument
	err := row.Scan(
		&i.ID,
		&i.KnowledgeItemID,
		&i.WorkspaceID,
		&i.ChunkIndex,
		&i.ChunkText,
		&i.TokenCount,
		&i.EmbeddingStatus,
		&i.EmbeddedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getEvidenceByID = `-- name: GetEvidenceByID :one
SELECT id, knowledge_item_id, workspace_id, method, score, snippet, pii_redacted, metadata, created_at FROM evidence
WHERE id = ? AND workspace_id = ?
LIMIT 1
`

type GetEvidenceByIDParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

// Task 2.6: Retrieve a single evidence record
func (q *Queries) GetEvidenceByID(ctx context.Context, arg GetEvidenceByIDParams) (Evidence, error) {
	row := q.db.QueryRowContext(ctx, getEvidenceByID, arg.ID, arg.WorkspaceID)
	var i Evidence
	err := row.Scan(
		&i.ID,
		&i.KnowledgeItemID,
		&i.WorkspaceID,
		&i.Method,
		&i.Score,
		&i.Snippet,
		&i.PiiRedacted,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getKnowledgeItemByEntity = `-- name: GetKnowledgeItemByEntity :one
SELECT id, workspace_id, source_type, title, raw_content, normalized_content, entity_type, entity_id, metadata, created_at, updated_at, deleted_at FROM knowledge_item
WHERE workspace_id = ? AND entity_type = ? AND entity_id = ? AND deleted_at IS NULL
LIMIT 1
`

type GetKnowledgeItemByEntityParams struct {
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
	EntityType  *string `db:"entity_type" json:"entityType"`
	EntityID    *string `db:"entity_id" json:"entityId"`
}

// Task 2.7: Find knowledge item linked to a CRM entity
func (q *Queries) GetKnowledgeItemByEntity(ctx context.Context, arg GetKnowledgeItemByEntityParams) (KnowledgeItem, error) {
	row := q.db.QueryRowContext(ctx, getKnowledgeItemByEntity, arg.WorkspaceID, arg.EntityType, arg.EntityID)
	var i KnowledgeItem
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.SourceType,
		&i.Title,
		&i.RawContent,
		&i.NormalizedContent,
		&i.EntityType,
		&i.EntityID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getKnowledgeItemByID = `-- name: GetKnowledgeItemByID :one
SELECT id, workspace_id, source_type, title, raw_content, normalized_content, entity_type, entity_id, metadata, created_at, updated_at, deleted_at FROM knowledge_item
WHERE id = ? AND workspace_id = ? AND deleted_at IS NULL
LIMIT 1
`

type GetKnowledgeItemByIDParams struct {
	ID          string `db:"id" json:"id"`
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
}

// Task 2.1/2.2: Retrieve a single knowledge item (excludes soft-deleted)
func (q *Queries) GetKnowledgeItemByID(ctx context.Context, arg GetKnowledgeItemByIDParams) (KnowledgeItem, error) {
	row := q.db.QueryRowContext(ctx, getKnowledgeItemByID, arg.ID, arg.WorkspaceID)
	var i KnowledgeItem
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.SourceType,
		&i.Title,
		&i.RawContent,
		&i.NormalizedContent,
		&i.EntityType,
		&i.EntityID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const insertVecEmbedding = `-- name: InsertVecEmbedding :exec

INSERT INTO vec_embedding (id, workspace_id, embedding, created_at)
VALUES (?, ?, ?, ?)
`

type InsertVecEmbeddingParams struct {
	ID          string    `db:"id" json:"id"`
	WorkspaceID string    `db:"workspace_id" json:"workspaceId"`
	Embedding   string    `db:"embedding" json:"embedding"`
	CreatedAt   time.Time `db:"created_at" json:"createdAt"`
}

// ============================================================================
// vec_embedding queries (Task 2.4)
// ============================================================================
// Task 2.4: Store a float32 vector as JSON TEXT for an embedding_document chunk.
func (q *Queries) InsertVecEmbedding(ctx context.Context, arg InsertVecEmbeddingParams) error {
	_, err := q.db.ExecContext(ctx, insertVecEmbedding,
		arg.ID,
		arg.WorkspaceID,
		arg.Embedding,
		arg.CreatedAt,
	)
	return err
}

const listEmbeddingDocumentsByKnowledgeItem = `-- name: ListEmbeddingDocumentsByKnowledgeItem :many
SELECT id, knowledge_item_id, workspace_id, chunk_index, chunk_text, token_count, embedding_status, embedded_at, created_at FROM embedding_document
WHERE knowledge_item_id = ? AND workspace_id = ?
ORDER BY chunk_index ASC
`

type ListEmbeddingDocumentsByKnowledgeItemParams struct {
	KnowledgeItemID string `db:"knowledge_item_id" json:"knowledgeItemId"`
	WorkspaceID     string `db:"workspace_id" json:"workspaceId"`
}

// Task 2.4: Get all chunks for a knowledge item (for embedding job)
func (q *Queries) ListEmbeddingDocumentsByKnowledgeItem(ctx context.Context, arg ListEmbeddingDocumentsByKnowledgeItemParams) ([]EmbeddingDocument, error) {
	rows, err := q.db.QueryContext(ctx, listEmbeddingDocumentsByKnowledgeItem, arg.KnowledgeItemID, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EmbeddingDocument{}
	for rows.Next() {
		var i EmbeddingDocument
		if err := rows.Scan(
			&i.ID,
			&i.KnowledgeItemID,
			&i.WorkspaceID,
			&i.ChunkIndex,
			&i.ChunkText,
			&i.TokenCount,
			&i.EmbeddingStatus,
			&i.EmbeddedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvidenceByKnowledgeItem = `-- name: ListEvidenceByKnowledgeItem :many
SELECT id, knowledge_item_id, workspace_id, method, score, snippet, pii_redacted, metadata, created_at FROM evidence
WHERE knowledge_item_id = ? AND workspace_id = ?
ORDER BY score DESC
`

type ListEvidenceByKnowledgeItemParams struct {
	KnowledgeItemID string `db:"knowledge_item_id" json:"knowledgeItemId"`
	WorkspaceID     string `db:"workspace_id" json:"workspaceId"`
}

// Task 2.6: List evidence for a knowledge item, ordered by score
func (q *Queries) ListEvidenceByKnowledgeItem(ctx context.Context, arg ListEvidenceByKnowledgeItemParams) ([]Evidence, error) {
	rows, err := q.db.QueryContext(ctx, listEvidenceByKnowledgeItem, arg.KnowledgeItemID, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Evidence{}
	for rows.Next() {
		var i Evidence
		if err := rows.Scan(
			&i.ID,
			&i.KnowledgeItemID,
			&i.WorkspaceID,
			&i.Method,
			&i.Score,
			&i.Snippet,
			&i.PiiRedacted,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvidenceByMethod = `-- name: ListEvidenceByMethod :many
SELECT id, knowledge_item_id, workspace_id, method, score, snippet, pii_redacted, metadata, created_at FROM evidence
WHERE workspace_id = ? AND method = ?
ORDER BY score DESC
LIMIT ? OFFSET ?
`

type ListEvidenceByMethodParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Method      string `db:"method" json:"method"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

// Task 2.6: List evidence filtered by search method
func (q *Queries) ListEvidenceByMethod(ctx context.Context, arg ListEvidenceByMethodParams) ([]Evidence, error) {
	rows, err := q.db.QueryContext(ctx, listEvidenceByMethod,
		arg.WorkspaceID,
		arg.Method,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Evidence{}
	for rows.Next() {
		var i Evidence
		if err := rows.Scan(
			&i.ID,
			&i.KnowledgeItemID,
			&i.WorkspaceID,
			&i.Method,
			&i.Score,
			&i.Snippet,
			&i.PiiRedacted,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKnowledgeItemsByEntity = `-- name: ListKnowledgeItemsByEntity :many
SELECT id, workspace_id, source_type, title, raw_content, normalized_content, entity_type, entity_id, metadata, created_at, updated_at, deleted_at FROM knowledge_item
WHERE workspace_id = ? AND entity_type = ? AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListKnowledgeItemsByEntityParams struct {
	WorkspaceID string  `db:"workspace_id" json:"workspaceId"`
	EntityType  *string `db:"entity_type" json:"entityType"`
	Limit       int64   `db:"limit" json:"limit"`
	Offset      int64   `db:"offset" json:"offset"`
}

// Task 2.7: List knowledge items linked to a specific entity type
func (q *Queries) ListKnowledgeItemsByEntity(ctx context.Context, arg ListKnowledgeItemsByEntityParams) ([]KnowledgeItem, error) {
	rows, err := q.db.QueryContext(ctx, listKnowledgeItemsByEntity,
		arg.WorkspaceID,
		arg.EntityType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KnowledgeItem{}
	for rows.Next() {
		var i KnowledgeItem
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.SourceType,
			&i.Title,
			&i.RawContent,
			&i.NormalizedContent,
			&i.EntityType,
			&i.EntityID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKnowledgeItemsByWorkspace = `-- name: ListKnowledgeItemsByWorkspace :many
SELECT id, workspace_id, source_type, title, raw_content, normalized_content, entity_type, entity_id, metadata, created_at, updated_at, deleted_at FROM knowledge_item
WHERE workspace_id = ? AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListKnowledgeItemsByWorkspaceParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

// Task 2.2: List all knowledge items for a workspace (paginated)
func (q *Queries) ListKnowledgeItemsByWorkspace(ctx context.Context, arg ListKnowledgeItemsByWorkspaceParams) ([]KnowledgeItem, error) {
	rows, err := q.db.QueryContext(ctx, listKnowledgeItemsByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KnowledgeItem{}
	for rows.Next() {
		var i KnowledgeItem
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.SourceType,
			&i.Title,
			&i.RawContent,
			&i.NormalizedContent,
			&i.EntityType,
			&i.EntityID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingEmbeddingsByWorkspace = `-- name: ListPendingEmbeddingsByWorkspace :many
SELECT id, knowledge_item_id, workspace_id, chunk_index, chunk_text, token_count, embedding_status, embedded_at, created_at FROM embedding_document
WHERE workspace_id = ? AND embedding_status = 'pending'
ORDER BY created_at ASC
LIMIT ? OFFSET ?
`

type ListPendingEmbeddingsByWorkspaceParams struct {
	WorkspaceID string `db:"workspace_id" json:"workspaceId"`
	Limit       int64  `db:"limit" json:"limit"`
	Offset      int64  `db:"offset" json:"offset"`
}

// Task 2.4: Get all chunks waiting to be embedded (for background job)
func (q *Queries) ListPendingEmbeddingsByWorkspace(ctx context.Context, arg ListPendingEmbeddingsByWorkspaceParams) ([]EmbeddingDocument, error) {
	rows, err := q.db.QueryContext(ctx, listPendingEmbeddingsByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EmbeddingDocument{}
	for rows.Next() {
		var i EmbeddingDocument
		if err := rows.Scan(
			&i.ID,
			&i.KnowledgeItemID,
			&i.WorkspaceID,
			&i.ChunkIndex,
			&i.ChunkText,
			&i.TokenCount,
			&i.EmbeddingStatus,
			&i.EmbeddedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteKnowledgeItem = `-- name: SoftDeleteKnowledgeItem :exec
UPDATE knowledge_item
SET deleted_at = ?
WHERE id = ? AND workspace_id = ?
`

type SoftDeleteKnowledgeItemParams struct {
	DeletedAt   *time.Time `db:"deleted_at" json:"deletedAt"`
	ID          string     `db:"id" json:"id"`
	WorkspaceID string     `db:"workspace_id" json:"workspaceId"`
}

// Task 2.2/2.7: Soft delete a knowledge item (preserves audit trail)
func (q *Queries) SoftDeleteKnowledgeItem(ctx context.Context, arg SoftDeleteKnowledgeItemParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteKnowledgeItem, arg.DeletedAt, arg.ID, arg.WorkspaceID)
	return err
}

const updateEmbeddingDocumentStatus = `-- name: UpdateEmbeddingDocumentStatus :exec
UPDATE embedding_document
SET embedding_status = ?, embedded_at = ?
WHERE id = ? AND workspace_id = ?
`

type UpdateEmbeddingDocumentStatusParams struct {
	EmbeddingStatus string     `db:"embedding_status" json:"embeddingStatus"`
	EmbeddedAt      *time.Time `db:"embedded_at" json:"embeddedAt"`
	ID              string     `db:"id" json:"id"`
	WorkspaceID     string     `db:"workspace_id" json:"workspaceId"`
}

// Task 2.4: Mark a chunk as embedded (or failed)
func (q *Queries) UpdateEmbeddingDocumentStatus(ctx context.Context, arg UpdateEmbeddingDocumentStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateEmbeddingDocumentStatus,
		arg.EmbeddingStatus,
		arg.EmbeddedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}

const updateKnowledgeItemNormalizedContent = `-- name: UpdateKnowledgeItemNormalizedContent :exec
UPDATE knowledge_item
SET normalized_content = ?, updated_at = ?
WHERE id = ? AND workspace_id = ?
`

type UpdateKnowledgeItemNormalizedContentParams struct {
	NormalizedContent *string   `db:"normalized_content" json:"normalizedContent"`
	UpdatedAt         time.Time `db:"updated_at" json:"updatedAt"`
	ID                string    `db:"id" json:"id"`
	WorkspaceID       string    `db:"workspace_id" json:"workspaceId"`
}

// Task 2.7: Update normalized content after CDC reindex
// Triggers knowledge_item_au which re-syncs FTS5 index
func (q *Queries) UpdateKnowledgeItemNormalizedContent(ctx context.Context, arg UpdateKnowledgeItemNormalizedContentParams) error {
	_, err := q.db.ExecContext(ctx, updateKnowledgeItemNormalizedContent,
		arg.NormalizedContent,
		arg.UpdatedAt,
		arg.ID,
		arg.WorkspaceID,
	)
	return err
}
